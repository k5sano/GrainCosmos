# DSP Architecture: GrainCosmos

**CRITICAL CONTRACT:** This specification is immutable during Stages 1-4 implementation. Stage 1 Planning cannot proceed without this file. Stage 3 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research
**Referenced by:** Stage 1 (Planning), Stage 3 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Grain Buffer (Circular Delay Line)
- **JUCE Class:** `juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Lagrange3rd>`
- **Purpose:** Store incoming audio for grain reading with interpolated playback
- **Parameters Affected:** delay_time, tempo_sync, freeze
- **Configuration:**
  - Buffer size: Maximum 2 seconds at sample rate (e.g., 96,000 samples at 48kHz)
  - Write continuously at current sample position (mono input)
  - Grains read from randomized positions within delay range
  - Lagrange3rd interpolation for smooth pitch-shifted playback
  - Tempo sync: When enabled, delay_time snaps to note divisions (1/16, 1/8, 1/4, 1/2, 1/1)
  - Freeze mode: When enabled, buffer writes stop (holds current content indefinitely)

### Grain Voice Engine
- **JUCE Class:** Custom implementation (polyphonic voice management)
- **Purpose:** Manage multiple simultaneous grain playbacks with independent states
- **Parameters Affected:** grain_size, envelope_shape, chaos, character, feedback
- **Configuration:**
  - Voice count: 32 maximum simultaneous grains (32 mono grains panned to stereo)
  - Voice structure per grain:
    - Read position in delay buffer (float for interpolation)
    - Window position (0.0-1.0 progress through grain envelope)
    - Pitch shift semitones (quantized to octaves/fifths: -12, -7, 0, +7, +12)
    - Pan position (0.0-1.0, randomized for stereo spread)
    - Envelope shape (ADSR parameters controlled by envelope_shape)
    - Active flag
  - Voice allocation: Linear search for inactive voice, steal oldest if all busy
  - Container: `std::array<GrainVoice, 32>`

### Grain Scheduler
- **JUCE Class:** Custom implementation (sample-based timer)
- **Purpose:** Trigger new grains based on delay_time and character (density control)
- **Parameters Affected:** delay_time, character, chaos
- **Configuration:**
  - Base spawn interval: delay_time parameter (10ms - 2s)
  - Character density adjustment:
    - At 0% (glitchy): Spawn at base delay_time interval (sparse, rhythmic)
    - At 100% (smooth): Spawn faster for dense overlap (continuous pad texture)
    - Density multiplier: `baseDensity = 1.0 + (character * 3.0)` (1-4 grains per delay period)
  - Chaos randomizes spawn timing: `spawnInterval *= (1.0 + chaos * random(-0.5, 0.5))`
  - Sample counter incremented each processBlock, triggers grain when counter >= interval

### Envelope Modulator (ADSR Shaping)
- **JUCE Class:** Custom implementation (per-grain envelope generation)
- **Purpose:** Generate variable ADSR envelope shapes per grain (beyond Tukey window)
- **Parameters Affected:** envelope_shape, grain_size
- **Configuration:**
  - Envelope types (crossfaded by envelope_shape 0.0-1.0):
    - At 0.0: Percussive envelope (fast attack, fast decay, no sustain)
      - Attack: 5% of grain duration
      - Decay: 95% of grain duration
      - Sustain: 0% (exponential decay)
      - Release: 0% (one-shot)
    - At 0.5: Balanced envelope (medium attack, medium decay, low sustain)
      - Attack: 15% of grain duration
      - Decay: 50% of grain duration
      - Sustain: 20% (linear portion)
      - Release: 15% of grain duration
    - At 1.0: Smooth envelope (slow attack, long sustain, slow release)
      - Attack: 30% of grain duration
      - Decay: 20% of grain duration
      - Sustain: 40% (linear portion)
      - Release: 10% of grain duration
  - Interpolation: Linear crossfade between envelope shapes based on envelope_shape
  - Per-grain calculation: envelope value at current window position (0.0-1.0)
  - Formula: `grainOutput = bufferSample * envelope[windowPos]`
  - Integrated with Tukey window from AngelGrain for character-controlled crossfade

### Waveshaping Distortion Unit
- **JUCE Class:** Custom implementation (polynomial waveshaper)
- **Purpose:** Apply non-linear timbral coloration to grain output
- **Parameters Affected:** distortion_amount
- **Configuration:**
  - Transfer function: Cubic polynomial `f(x) = x + k*x^3` where k = distortion_amount
  - Distortion range: 0.0 (clean) to 100.0 (heavily distorted)
  - Drive mapping: `k = distortion_amount / 100.0 * 5.0` (max gain of 5.0 for cubic term)
  - Soft clipping: `tanh(output)` to prevent digital overflow
  - Placement: Post-grain engine, pre-feedback (distorted grains feed back)
  - Alternative (if polynomial insufficient): Wavetable-based waveshaping
    - Pre-calculate transfer function: 1024-point table `f(x) = tanh(x + k*x^3)`
    - Linear interpolation from table for each sample
    - Lower CPU than per-sample polynomial calculation

### Freeze State Controller
- **JUCE Class:** Custom implementation (boolean state flag)
- **Purpose:** Hold buffer content, stop writes, freeze grains in place
- **Parameters Affected:** freeze
- **Configuration:**
  - State flag: `std::atomic<bool> freezeEnabled`
  - When freeze = true:
    - Buffer writes stop (delay line holds current content)
    - Grain scheduler continues spawning (grains read from frozen buffer)
    - Feedback loop continues (frozen signal feeds back, creating infinite freeze)
    - New input ignored (not written to buffer)
  - When freeze = false:
    - Normal operation resumes
    - Buffer writes continue
    - New input overwrites old content
  - Edge case: On freeze disable, ramp input gain from 0.0 to 1.0 over 50ms to prevent clicks

### Window Function Generator
- **JUCE Class:** `juce::dsp::WindowingFunction<float>`
- **Purpose:** Apply smooth amplitude envelope to grains (crossfade control)
- **Parameters Affected:** grain_size, character
- **Configuration:**
  - Window type: Tukey window (cosine-tapered) for controllable crossfade
  - Tukey alpha parameter controlled by character:
    - At 0% (glitchy): alpha = 0.1 (short crossfades, abrupt edges)
    - At 100% (smooth): alpha = 1.0 (full Hann-like envelope, long crossfades)
    - Formula: `alpha = 0.1 + (character * 0.9)`
  - Alternative: Use Hann window and scale crossfade portion dynamically
  - Combined with envelope_shape: Multiply Tukey window * ADSR envelope per sample

### Pitch Quantization System (Octaves and Fifths)
- **JUCE Class:** Custom implementation (lookup table + random selection)
- **Purpose:** Constrain pitch randomization to harmonically pure intervals (octaves and fifths)
- **Parameters Affected:** chaos
- **Configuration:**
  - Available pitch shifts (semitones): [-12, -7, 0, +7, +12]
    - -12: One octave down
    - -7: Perfect fifth down
    - 0: No pitch shift
    - +7: Perfect fifth up
    - +12: One octave up
  - Selection algorithm:
    1. Generate random value 0.0-1.0
    2. Scale by chaos: `randomAmount = random * (chaos / 100)`
    3. At low chaos: Mostly 0 (unison)
    4. At high chaos: Full range of pitch shifts
    5. Weighted selection toward 0 at low chaos, uniform at high chaos
  - Playback rate formula: `rate = pow(2.0f, semitones / 12.0f)`
    - Examples: +12 = 2.0x (double speed), -12 = 0.5x (half speed), +7 = ~1.498x

### Random Pan Generator
- **JUCE Class:** `juce::Random` (from `juce_core`)
- **Purpose:** Randomize stereo position per grain for spatial texture
- **Parameters Affected:** chaos
- **Configuration:**
  - Pan range: 0.0 (full left) to 1.0 (full right)
  - Pan randomization scaled by chaos:
    - At 0%: All grains centered (0.5)
    - At 100%: Full stereo spread (0.0-1.0)
    - Formula: `pan = 0.5 + (random - 0.5) * (chaos / 100)`
  - Applied per grain: `leftGain = cos(pan * PI/2)`, `rightGain = sin(pan * PI/2)` (equal-power pan)

### Position Randomization
- **JUCE Class:** Custom implementation
- **Purpose:** Randomize grain read position within delay buffer for variation
- **Parameters Affected:** chaos
- **Configuration:**
  - Base position: Delay time minus grain size (start of buffer region to read)
  - Position randomization scaled by chaos:
    - At 0%: Fixed position (rhythmic, regular)
    - At 100%: Full randomization within delay buffer
    - Formula: `position = basePosition * (1.0 + (random - 0.5) * (chaos / 100) * 0.5)`
  - Ensures grain stays within valid buffer range

### Feedback Loop
- **JUCE Class:** Custom implementation (manual buffer mixing)
- **Purpose:** Feed processed grain output back into delay buffer for evolving textures
- **Parameters Affected:** feedback
- **Configuration:**
  - Feedback gain: 0.0-0.95 (0-100% parameter mapped to prevent runaway)
  - Feedback signal is stereo (summed to mono for mono grain buffer input)
  - Formula: `inputSample = drySample + ((leftOutput + rightOutput) * 0.5f * feedbackGain)`
  - Apply soft saturation at high feedback: `tanh(feedbackSignal)` to prevent clipping/instability
  - Freeze mode feedback: When freeze enabled, feedback still applies (frozen signal continues recirculating)

### Dry/Wet Mixer
- **JUCE Class:** `juce::dsp::DryWetMixer<float>`
- **Purpose:** Blend unprocessed input with granular-processed output
- **Parameters Affected:** mix
- **Configuration:**
  - MIX (0-100%) maps to wet proportion (0.0-1.0)
  - Input is mono, output is stereo
  - Dry signal: Mono duplicated to both stereo channels
  - Wet signal: Stereo grain output
  - `pushDrySamples()` before processing, `mixWetSamples()` after

---

## Processing Chain

```
Input (Mono)
  |
Dry/Wet Mixer (capture dry) ← MIX
  |
Mix with Feedback Signal ← FEEDBACK
  |
Write to Grain Buffer (if not frozen) ← delay_time, FREEZE
  |
Grain Scheduler (trigger new grains) ← delay_time, character, chaos
  |
For each active grain (up to 32 voices):
  |
  +-- Read from Grain Buffer (interpolated) ← Position randomization (chaos)
  +-- Apply Pitch Shift (playback rate) ← Pitch quantization (chaos)
  +-- Generate ADSR Envelope ← envelope_shape, grain_size
  +-- Apply Tukey Window ← grain_size, character (crossfade)
  +-- Multiply: sample * ADSR * Tukey (combined envelope)
  +-- Apply Waveshaping Distortion ← distortion_amount
  +-- Apply Pan Position ← Pan randomization (chaos)
  |
Sum all active grain outputs (Stereo)
  |
Apply Feedback Gain ← FEEDBACK
  |
Feed back to input (stereo summed to mono)
  |
Dry/Wet Mixer (blend) ← MIX
  |
Output (Stereo)
```

**Routing notes:**
- Mono input, stereo output (grain panning creates stereo field)
- Feedback loop: Stereo grain output -> summed to mono -> mixed with input -> grain buffer
- Distortion placement: Post-grain engine, pre-feedback (distorted timbre feeds back)
- Parallel grain voices: All 32 voices process independently, outputs summed
- Character affects both grain density (spawn rate) AND crossfade envelope shape (Tukey alpha)
- Chaos scales four randomization dimensions: position, pitch, pan, timing
- Freeze mode: Buffer writes stop, grains read from frozen content, feedback continues
- Envelope shape: Crossfades between percussive/balanced/smooth ADSR profiles

---

## System Architecture

### Tempo Sync System

**DAW integration:** Query host for tempo information

**JUCE classes:**
- `juce::AudioPlayHead` - Host transport state
- `juce::AudioPlayHead::getCurrentPosition()` - Get current tempo (BPM)

**Note division mapping (at 120 BPM):**
- 1/16 note: 125ms
- 1/8 note: 250ms
- 1/4 note: 500ms
- 1/2 note: 1000ms
- 1 (whole): 2000ms

**Implementation:**
- When tempo_sync = true:
  - Query BPM from playhead
  - Quantize delay_time to nearest note division
  - Recalculate on tempo change or parameter change
- When tempo_sync = false:
  - Use delay_time directly in ms (free-running)

**Error handling:**
- If playhead unavailable (offline bounce): Use default 120 BPM
- If tempo invalid (<20 or >300 BPM): Clamp to valid range

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| delay_time | Float | 0.0-2.0s | Grain Buffer, Grain Scheduler | Buffer read position, spawn interval base |
| grain_size | Float | 10-500ms | Envelope Modulator, Window Function | ADSR duration, window length |
| envelope_shape | Float | 0.0-1.0 | Envelope Modulator | Crossfade between percussive/balanced/smooth ADSR |
| distortion_amount | Float | 0-100% | Waveshaping Distortion | Polynomial gain factor (0.0-5.0) |
| feedback | Float | 0-95% | Feedback Loop | Feedback gain (0.0-0.95) |
| chaos | Float | 0-100% | All randomization systems | Master randomization amount |
| character | Float | 0-100% | Grain Scheduler, Window Function | Density (spawn rate) + crossfade (envelope shape) |
| mix | Float | 0-100% | Dry/Wet Mixer | Wet proportion (0.0-1.0) |
| freeze | Bool | On/Off | Freeze State Controller | Buffer write enable flag |
| tempo_sync | Bool | On/Off | Grain Scheduler | Enable note division quantization |

---

## Algorithm Details

### Envelope Modulation System (ADSR Shaping)

**Algorithm:** Variable envelope generation with linear crossfade between preset shapes

**Implementation notes:**
- Three envelope shapes crossfaded by envelope_shape (0.0-1.0):
  1. **Percussive** (envelope_shape = 0.0):
     - Attack: 5% of grain duration
     - Decay: 95% of grain duration (exponential)
     - Sustain: 0% (no sustain portion)
     - Release: 0% (one-shot, no release tail)
  2. **Balanced** (envelope_shape = 0.5):
     - Attack: 15% of grain duration
     - Decay: 50% of grain duration
     - Sustain: 20% (linear sustain)
     - Release: 15% of grain duration
  3. **Smooth** (envelope_shape = 1.0):
     - Attack: 30% of grain duration
     - Decay: 20% of grain duration
     - Sustain: 40% (long sustain)
     - Release: 10% of grain duration

- Per-grain envelope calculation:
  ```cpp
  // Crossfade between envelope shapes
  float envShape = envelope_shape; // 0.0 - 1.0
  float windowPos = currentGrainPos / grainSizeSamples; // 0.0 - 1.0

  // Percussive envelope (shape A)
  float envPercussive;
  if (windowPos < 0.05f) {
      envPercussive = windowPos / 0.05f; // Attack
  } else {
      envPercussive = 1.0f - (windowPos - 0.05f) / 0.95f; // Decay
  }

  // Balanced envelope (shape B)
  float envBalanced;
  if (windowPos < 0.15f) {
      envBalanced = windowPos / 0.15f; // Attack
  } else if (windowPos < 0.65f) {
      envBalanced = 1.0f - (windowPos - 0.15f) * 0.5f; // Decay + Sustain
  } else {
      envBalanced = (1.0f - windowPos) / 0.35f; // Release
  }

  // Smooth envelope (shape C)
  float envSmooth;
  if (windowPos < 0.30f) {
      envSmooth = windowPos / 0.30f; // Attack
  } else if (windowPos < 0.50f) {
      envSmooth = 1.0f - (windowPos - 0.30f) * 0.5f; // Decay
  } else if (windowPos < 0.90f) {
      envSmooth = 1.0f; // Sustain
  } else {
      envSmooth = (1.0f - windowPos) / 0.10f; // Release
  }

  // Linear crossfade
  float adsrEnvelope;
  if (envShape < 0.5f) {
      float t = envShape * 2.0f;
      adsrEnvelope = envPercussive * (1.0f - t) + envBalanced * t;
  } else {
      float t = (envShape - 0.5f) * 2.0f;
      adsrEnvelope = envBalanced * (1.0f - t) + envSmooth * t;
  }
  ```

- Combined envelope: `finalEnvelope = adsrEnvelope * tukeyWindow[windowPos]`
  - ADSR provides grain-level shaping
  - Tukey provides character-controlled crossfade (AngelGrain heritage)

---

### Waveshaping Distortion

**Algorithm:** Polynomial cubic distortion with soft clipping

**Implementation notes:**
- Transfer function: `f(x) = x + k*x^3`
  - k = distortion gain factor (0.0 to 5.0)
  - At k=0: Linear (clean)
  - At k=5.0: Heavy distortion (odd harmonics emphasis)
- Distortion amount mapping: `k = (distortion_amount / 100.0) * 5.0`
- Soft clipping: `output = tanh(input)` to prevent overflow
- Applied per-sample: `distorted = tanh(cleanSample + k * pow(cleanSample, 3))`

**Alternative (wavetable-based):**
- Pre-calculate transfer function: `table[i] = tanh(x + k*x^3)` for x in [-1, 1]
- Linear interpolation from table: `output = interpolate(table, input, tableSize)`
- Lower CPU if polynomial calculation proves expensive
- Trade-off: Slightly more memory, faster per-sample processing

---

### Freeze Buffer Hold

**Algorithm:** Conditional buffer write enable with infinite feedback loop

**Implementation notes:**
- Atomic flag: `std::atomic<bool> freezeEnabled`
- Write logic:
  ```cpp
  if (!freezeEnabled.load()) {
      // Normal: write input + feedback to buffer
      float writeSample = drySample + feedbackSignal;
      grainBuffer.push(writeSample);
  } else {
      // Frozen: skip write, buffer holds current content
      // Grains continue reading from frozen buffer
  }
  ```

- Feedback loop continues in freeze mode:
  - Frozen grain output feeds back
  - Creates infinite sustain of frozen moment
  - Allows textural evolution within frozen buffer

- Freeze state edge handling:
  - On freeze enable: Instant (no ramp)
  - On freeze disable: Ramp input gain 0.0→1.0 over 50ms
    - Prevents click when unfreezing
    - Formula: `inputGain = min(1.0f, timeSinceDisable / 0.05f)`

---

### Combined Envelope System (Tukey + ADSR)

**Algorithm:** Dual envelope multiplication for grain shaping

**Implementation notes:**
- Tukey window (from AngelGrain):
  - Alpha controlled by character (0.1 to 1.0)
  - Provides crossfade control (glitchy ↔ smooth)
  - Formula: See AngelGrain architecture

- ADSR envelope (new):
  - Shape controlled by envelope_shape (0.0 to 1.0)
  - Provides temporal shaping (percussive ↔ balanced ↔ smooth)
  - Formula: See Envelope Modulation System above

- Combined multiplication:
  ```cpp
  float tukeyWindow = generateTukeyWindow(windowPos, character);
  float adsrEnvelope = generateADSR(windowPos, envelope_shape);
  float finalEnvelope = tukeyWindow * adsrEnvelope;
  float grainOutput = bufferSample * finalEnvelope;
  ```

- Interaction:
  - At low character: Short Tukey crossfade + variable ADSR = glitchy, clicky grains
  - At high character: Long Tukey crossfade + variable ADSR = smooth, blurred grains
  - Envelope shape adds independent control over attack/decay/sustain/release

---

## Integration Points

### Feature Dependencies

- **Grain scheduler → Voice engine:** Scheduler triggers grain spawns, voice engine allocates voices
- **Voice engine → Grain buffer:** Voices read from grain buffer at various positions
- **Chaos → All randomization:** Chaos parameter scales position, pitch, pan, timing
- **Character → Density + Window:** Character affects spawn rate AND Tukey window shape
- **Envelope_shape → Envelope Modulator:** Controls ADSR crossfade (independent of character)
- **Distortion → Feedback loop:** Distorted output feeds back (coloration accumulates)
- **Freeze → Grain buffer:** Freeze stops writes but grains continue reading (infinite sustain)
- **Feedback → Grain buffer input:** Feedback output mixed with input before buffer write
- **All grain voices → Dry/wet mixer:** Summed stereo grain output blended with dry signal

---

### Parameter Interactions

- **Chaos affects multiple systems simultaneously:**
  - Position: Higher chaos = more grain position jitter
  - Pitch: Higher chaos = more pitch variation (octaves/fifths vs unison)
  - Pan: Higher chaos = wider stereo spread
  - Timing: Higher chaos = more irregular spawn timing
  - Interaction: At 0% chaos, output is rhythmic and centered; at 100%, output is chaotic and spread

- **Character affects density AND crossfade together:**
  - Low character (0%): Sparse + abrupt = glitchy/stuttering texture
  - High character (100%): Dense + smooth = pad-like/angelic texture
  - Interaction: They reinforce each other (sparse + smooth or dense + abrupt would be contradictory)

- **Envelope_shape adds independent temporal control:**
  - At 0% (percussive): Fast attack, fast decay, no sustain = clicks, transients
  - At 1.0 (smooth): Slow attack, long sustain, slow release = bowed, evolving
  - Combines with character: percussive + glitchy = rhythmic stutters; smooth + dense = ambient pad

- **Distortion + Feedback create evolving timbral textures:**
  - Distortion alone: Colored grains without accumulation
  - Feedback alone: Clean recirculation
  - Both together: Distorted timbre feeds back, accumulates harmonics
  - Risk: High feedback + high distortion can become harsh (intentional creative effect)

- **Freeze + Chaos create frozen randomness:**
  - Freeze alone: Static loop of buffer content
  - Chaos alone: Evolving, decaying grains
  - Both together: Frozen buffer, randomized grain positions, infinite sustain
  - Creative use: Freeze interesting moment, chaos varies grain selection from frozen content

- **GrainSize + DelayTime interaction:**
  - GrainSize > DelayTime: Grains overlap significantly (potential for artifacts)
  - GrainSize << DelayTime: Sparse grains with gaps
  - Balanced: GrainSize ~= DelayTime/2 to DelayTime for smooth overlap

---

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

1. **Capture dry signal:** Store mono input in DryWetMixer
   - Must happen first to preserve clean input

2. **Mix feedback with input:** Combine dry mono input with feedback signal
   - Feedback from previous cycle (stereo summed to mono)

3. **Check freeze state:** If freeze disabled, write to buffer; if enabled, skip write
   - Frozen buffer: grains read from held content
   - Normal operation: buffer updates with (input + feedback)

4. **Grain scheduler tick:** Check if new grain should spawn
   - Based on delay_time, character density, chaos timing jitter
   - Sample counter incremented, trigger when counter >= interval

5. **Spawn new grain (if triggered):** Allocate voice, randomize parameters
   - Randomize: Position, pitch (quantize to octaves/fifths), pan
   - Calculate playback rate from pitch shift
   - Generate combined envelope: Tukey (character) * ADSR (envelope_shape)

6. **Process all active grains:** Read from buffer, apply envelope, distortion, pan
   - Each grain reads at its own position with playback rate
   - Generate ADSR envelope based on envelope_shape
   - Generate Tukey window based on character
   - Multiply envelopes: `envelope = adsr * tukey`
   - Apply envelope: `output = bufferSample * envelope`
   - Apply waveshaping distortion: `distorted = tanh(output + k * output^3)`
   - Apply pan (stereo positioning with equal-power pan law)
   - Sum all grain outputs to stereo

7. **Apply feedback gain:** Scale grain output for feedback loop
   - Sum stereo to mono for feedback signal
   - Apply soft saturation at high feedback

8. **Blend with dry signal:** Mix stereo grain output with mono dry
   - DryWetMixer combines based on mix parameter
   - Dry signal duplicated to both channels

**Why order matters:**
- Dry capture first: Prevents feedback-contaminated dry signal
- Feedback before write: Feedback must mix with input before buffer write
- Freeze check at write: Controls whether buffer updates or holds
- Grain spawn after write: Grains read from buffer with latest input + feedback (or frozen content)
- Envelope multiplication: ADSR and Tukey combined before application to sample
- Distortion before feedback: Distorted timbre feeds back into buffer
- Feedback gain after grain sum: Total output controls feedback amount

---

### Thread Boundaries

**Threads:**
- **Audio thread:** All DSP processing in `processBlock()`
- **Message thread:** UI interactions, parameter updates
- **No background thread needed:** All processing is real-time

**Audio thread:**
- Grain processing (voice management, envelope application, buffer reads)
- Grain buffer write/read with freeze state check
- Envelope modulation (ADSR generation)
- Waveshaping distortion (polynomial calculation)
- Feedback mixing
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic)

**Message thread:**
- Parameter updates from UI via APVTS (atomic writes)
- Preset loading/saving
- UI repaints

**Communication:**
- APVTS parameters: Atomic reads (audio thread) / atomic writes (message thread)
- Freeze state: `std::atomic<bool>` for thread-safe read/write
- No custom thread communication needed (APVTS handles it)

**Safety guarantees:**
- Audio thread NEVER allocates memory (pre-allocated voice array)
- Audio thread NEVER waits on locks
- Envelope calculations should be efficient (avoid per-sample pow() calls if possible)
- Consider pre-calculating envelope tables for performance

---

## Implementation Risks

### Envelope Modulation System (ADSR + Tukey)

**Complexity:** MEDIUM
- Dual envelope multiplication (ADSR × Tukey)
- Per-grain envelope calculation with crossfade
- More complex than AngelGrain's Tukey-only approach

**Risk Level:** MEDIUM

**Risk factors:**
1. CPU usage with per-grain envelope calculation
   - Each grain: Envelope generation × 2 (ADSR + Tukey) + multiplication
   - Estimated: +10-15% CPU over AngelGrain base
2. Envelope crossfade logic adds branching per sample
3. Determining optimal ADSR shapes (percussive/balanced/smooth) is subjective
4. Interaction between envelope_shape and character parameters may be confusing

**Alternative approaches:**
1. **Simpler envelope system (single shape):**
   - Complexity: LOW
   - CPU: ~5% over base
   - Quality: Less flexibility, no envelope modulation
   - Best for: v1.0.0 if dual envelope proves too complex

2. **Pre-calculated envelope tables:**
   - Pre-calculate 11 envelope shapes (0.0, 0.1, 0.2, ..., 1.0)
   - Linear interpolate between tables for intermediate envelope_shape values
   - Lower CPU, slight quality loss
   - Best for: Performance optimization

**Fallback architecture:**
- **Primary:** Dual envelope (ADSR × Tukey) with per-sample calculation
- **Fallback 1:** Reduce to 7 envelope shapes (0.0, 0.16, 0.33, 0.5, 0.66, 0.83, 1.0) if CPU too high
- **Fallback 2:** Remove envelope_shape parameter, use fixed ADSR if dual envelope UX is confusing
- **Fallback 3:** Use AngelGrain's Tukey-only approach if envelope modulation proves unnecessary

**Mitigation strategy:**
1. Profile CPU usage early in implementation (measure per-grain cost)
2. Test with extreme parameters (100% character = 4x density, 5ms grain size, 1.0 envelope_shape)
3. Consider pre-calculating envelope tables if per-sample calculation is too expensive
4. If dual envelope interaction is confusing, simplify to single envelope parameter (v2.0.0 improvement)

---

### Waveshaping Distortion

**Complexity:** LOW-MEDIUM
- Polynomial transfer function is straightforward
- Soft clipping prevents overflow
- Placement in signal path is simple (pre-feedback)

**Risk Level:** LOW

**Risk factors:**
1. Polynomial calculation `pow(x, 3)` may be expensive at 48kHz
2. Distortion feedback loop can create harsh artifacts at high settings
3. No existing JUCE waveshaping class (custom implementation)

**Alternative approaches:**
1. **Wavetable-based distortion:**
   - Complexity: MEDIUM
   - CPU: ~5% (lower than per-sample polynomial)
   - Quality: Same, with pre-calculated transfer function
   - Best for: Performance optimization

2. **Simple soft clipping only:**
   - Complexity: LOW
   - CPU: ~2%
   - Quality: Less rich harmonics (just `tanh`)
   - Best for: v1.0.0 fallback if polynomial is problematic

**Fallback architecture:**
- **Primary:** Polynomial waveshaping with soft clipping
- **Fallback 1:** Wavetable-based distortion if polynomial CPU is too high
- **Fallback 2:** Simple soft clipping (`tanh`) if both approaches fail
- **Fallback 3:** Remove distortion entirely if it doesn't add musical value

**Mitigation strategy:**
1. Benchmark polynomial vs wavetable performance early
2. Test distortion + feedback interaction (listen for harshness)
3. If CPU exceeds 70% single core, switch to wavetable
4. If distortion feels unmusical, simplify to soft clipping or remove

---

### Freeze Buffer Hold

**Complexity:** LOW
- Simple atomic boolean flag
- Conditional buffer write logic
- Edge handling (ramp on disable)

**Risk Level:** LOW

**Risk factors:**
1. Clicking on freeze disable if no input gain ramp
2. Infinite feedback loop in freeze mode (potential for runaway if feedback > 0.95)
3. Buffer holds old content when unfrozen (user expectation mismatch)

**Alternative approaches:**
1. **Freeze with feedback disable:**
   - Complexity: LOW
   - Behavior: Freeze stops feedback loop
   - Trade-off: Static frozen buffer vs evolving frozen texture
   - Best for: Simpler mental model (freeze = pause)

2. **Freeze with fade-out:**
   - Complexity: LOW
   - Behavior: Freeze fades buffer content over 5 seconds
   - Trade-off: No true infinite sustain
   - Best for: Ambient applications (gradual fade)

**Fallback architecture:**
- **Primary:** Freeze with continued feedback loop (infinite sustain)
- **Fallback 1:** Disable feedback when freeze enabled if runaway is problematic
- **Fallback 2:** Remove freeze feature if UX is confusing (v2.0.0 improvement)

**Mitigation strategy:**
1. Implement input gain ramp on freeze disable (prevent clicks)
2. Test with high feedback settings in freeze mode (listen for runaway)
3. Add visual indicator in UI when freeze is active (user awareness)
4. Document freeze behavior in manual (feedback continues, buffer held)

---

### Granular Synthesis Engine (Base from AngelGrain)

**Complexity:** HIGH
- Polyphonic voice management (32 voices)
- Real-time grain scheduling
- Per-grain envelope with dual multiplication (ADSR + Tukey)
- Complex state management

**Risk Level:** MEDIUM (lower than AngelGrain due to proven architecture)

**Risk factors:**
1. CPU usage with 32 simultaneous grains at high density + dual envelope calculation
   - Each grain: Buffer read (interpolated), envelope ×2, distortion, pan calculation
   - Estimated: ~40-60% CPU at 32 voices, 48kHz (higher than AngelGrain)
2. Voice allocation logic must be efficient (linear search per grain spawn)
3. Dual envelope (ADSR + Tukey) increases per-grain cost significantly

**Alternative approaches:**
1. **Fixed lower voice count (16 voices):**
   - Complexity: Same
   - CPU: ~20-30% (lower)
   - Quality: Less dense textures at high character

2. **Pre-calculated dual envelope tables:**
   - Pre-calculate combined envelopes for character (0-100%) × envelope_shape (0.0-1.0)
   - 11 × 11 = 121 tables (character steps) × (envelope_shape steps)
   - Select nearest table at grain spawn
   - Lower CPU, slight quality loss

**Fallback architecture:**
- **Primary:** 32 polyphonic grain voices with dual envelope (ADSR + Tukey)
- **Fallback 1:** Reduce to 16 voices if CPU exceeds 70% single core
- **Fallback 2:** Use pre-calculated envelope tables (121 table combinations)
- **Fallback 3:** Remove envelope_shape parameter (Tukey-only) if dual envelope proves unnecessary

**Mitigation strategy:**
1. Reuse AngelGrain's proven voice management code (copy structure, modify envelope)
2. Profile voice processing loop early (Stage 3)
3. Test with extreme parameters (100% character = 4x density, 5ms grain size, 1.0 envelope_shape)
4. Consider pre-calculating envelope tables if per-sample calculation is too expensive
5. Implement CPU monitoring (warn user if >70% sustained)

---

### Overall Project Risk

**Overall complexity:** MEDIUM-HIGH
- Granular engine (HIGH) + envelope modulation (MEDIUM) + distortion (LOW-MEDIUM) + freeze (LOW)
- Higher complexity than AngelGrain due to envelope modulation and distortion
- AngelGrain architecture is proven (reduces risk significantly)

**Highest risk component:** Granular Synthesis Engine with Dual Envelope
- Represents ~60% of project risk
- Most CPU-intensive
- Complex voice management
- Dual envelope multiplication is new (not validated in AngelGrain)

**Recommended approach:**
1. **Phase 1 - Core engine:** Copy AngelGrain architecture, implement grain voices, scheduler, basic playback
2. **Phase 2 - Envelope modulation:** Add ADSR envelope system, combine with Tukey window
3. **Phase 3 - Distortion:** Add waveshaping unit, integrate with feedback loop
4. **Phase 4 - Freeze:** Implement buffer hold state, edge handling
5. **Phase 5 - Polish:** Optimize CPU, tune parameters, add fallbacks

---

## Architecture Decisions

### Envelope Modulation Approach (Dual Envelope vs Single)

**Decision:** Use dual envelope multiplication (ADSR × Tukey)

**Rationale:**
- Creative brief specifies "envelope modulation" as key new feature
- Provides independent control over temporal shaping (envelope_shape) and crossfade (character)
- ADSR allows percussive-to-smooth morphing beyond Tukey's crossfade control
- Dual system enables richer variety: percussive glitch (low envelope_shape + low character) to smooth pad (high envelope_shape + high character)

**Alternatives considered:**
1. **Tukey-only (AngelGrain approach):**
   - Why rejected: Doesn't fulfill "envelope modulation" requirement from creative brief
   - When to reconsider: If dual envelope UX is confusing or CPU-prohibitive

2. **Single envelope with shape parameter:**
   - Why rejected: Less flexible, can't independently control crossfade and temporal shape
   - When to reconsider: If dual envelope interaction is too complex for users

**Tradeoffs accepted:**
- **Higher CPU usage:** Dual envelope requires per-sample calculation of two envelope functions
  - Acceptable because: Granular synthesis is already CPU-intensive, envelope is small fraction of total cost (~10-15%)
- **Parameter interaction complexity:** envelope_shape and character both affect envelope
  - Acceptable because: They control different aspects (temporal shape vs crossfade), professional users will understand distinction
- **Implementation complexity:** More code than single envelope
  - Acceptable because: Reusing AngelGrain's proven architecture, adding envelope multiplication is straightforward

---

### Waveshaping Distortion Type (Polynomial vs Wavetable)

**Decision:** Use polynomial waveshaping with soft clipping

**Rationale:**
- Simple to implement (single formula: `f(x) = x + k*x^3`)
- No additional memory (wavetable requires pre-calculated buffer)
- Professional plugins use polynomial distortion (FabFilter Saturn, UAD Culture Vulture)
- Odd-harmonic emphasis from cubic term adds musical warmth

**Alternatives considered:**
1. **Wavetable-based distortion:**
   - Why rejected: Adds memory and table management complexity
   - When to reconsider: If polynomial CPU cost is too high

2. **Simple soft clipping only:**
   - Why rejected: Less rich harmonics, less creative potential
   - When to reconsider: If distortion feels unmusical or harsh

**Tradeoffs accepted:**
- **CPU usage:** Per-sample `pow()` call for cubic term
  - Acceptable because: Can optimize with `x*x*x` if needed, wavetable fallback available
- **Less flexibility than wavetable:** Fixed polynomial shape
  - Acceptable because: Single distortion_amount parameter provides sufficient control for v1.0.0

---

### Distortion Placement (Pre-Feedback vs Post-Feedback)

**Decision:** Place distortion pre-feedback (distorted grains feed back)

**Rationale:**
- Distorted timbre accumulates in feedback loop (creative potential)
- Harmonics from distortion create rich, evolving textures
- Matches professional granular plugins (Output Portal, Arturia Efx Fragments)

**Alternatives considered:**
1. **Post-feedback distortion:**
   - Why rejected: Clean feedback, less texture evolution
   - When to reconsider: If pre-feedback proves too harsh or chaotic

**Tradeoffs accepted:**
- **Potential for harsh artifacts:** High distortion + high feedback can become unmusical
  - Acceptable because: Users can lower distortion or feedback, creative effect
- **Less predictable:** Distortion accumulation in feedback loop is hard to anticipate
  - Acceptable because: Granular synthesis is inherently experimental/creative

---

### Freeze Behavior (Feedback Continued vs Disabled)

**Decision:** Keep feedback loop active during freeze (infinite sustain)

**Rationale:**
- Creates ambient "infinite sustain" of frozen moment
- Allows textural evolution within frozen buffer (chaos varies grain selection)
- Matches freeze behavior in professional plugins (Red Panda Particle, Superparticle)

**Alternatives considered:**
1. **Disable feedback when freeze enabled:**
   - Why rejected: Static loop, less creative potential
   - When to reconsider: If continued feedback causes runaway or confusion

**Tradeoffs accepted:**
- **Potential for runaway:** High feedback + freeze can build up artifacts
  - Acceptable because: Feedback capped at 0.95, users can lower feedback
- **More complex mental model:** Freeze doesn't "pause" everything
  - Acceptable because: Infinite sustain is more musically useful

---

## Special Considerations

### Thread Safety
- All parameter reads use atomic `getRawParameterValue()->load()` (APVTS)
- Freeze state uses `std::atomic<bool>` for thread-safe read/write
- Voice array pre-allocated in `prepareToPlay()` (no allocations in `processBlock()`)
- Grain scheduler uses sample counter (no time-based operations in audio thread)
- Consider pre-calculating envelope tables for performance (avoid per-sample pow/cos/sin)

### Performance
- **Estimated CPU usage:**
  - Granular engine (32 voices): ~30-45% single core
  - Dual envelope (ADSR + Tukey): ~10-15% (over AngelGrain base)
  - Waveshaping distortion: ~5-10%
  - Total: ~45-70% single core at 48kHz, 512 sample buffer
- **Optimization opportunities:**
  - Pre-calculate envelope tables for common character/envelope_shape combinations
  - Use `x*x*x` instead of `pow(x, 3)` for cubic distortion
  - Use SIMD for grain summing (`juce::FloatVectorOperations::add`)
  - Early-exit inactive voices
- **Buffer size sensitivity:**
  - Smaller buffers (64 samples) -> more overhead
  - Larger buffers (2048 samples) -> better efficiency

### Denormal Protection
- Use `juce::ScopedNoDenormals` in `processBlock()`
- Grain voices may produce denormals near envelope end (fade to zero)
- Feedback loop may accumulate denormals at high feedback
- DelayLine and DryWetMixer handle denormals internally
- Distortion polynomial may produce denormals near zero (input gain ramp prevents this)

### Sample Rate Handling
- Grain buffer resized in `prepareToPlay()` based on sample rate
- Maximum 2 seconds at any sample rate (e.g., 384,000 samples at 192kHz)
- Grain scheduler recalculates spawn interval on sample rate change
- Envelope tables (if used) regenerated on sample rate change
- Playback rate calculation is sample-rate-independent

**Sample rate scaling:**
- 44.1kHz: delay_time 1000ms = ~44,100 samples
- 48kHz: delay_time 1000ms = ~48,000 samples
- 96kHz: delay_time 1000ms = ~96,000 samples

### Latency
- **Processing latency sources:**
  - Grain buffer read: 10-2000ms (user-controlled via delay_time)
  - No FFT latency (time-domain pitch shifting)
  - No lookahead
- **Host compensation:**
  - Granular delay is creative effect, not precision time-alignment
  - Could report delay_time as latency, but varies with parameter
  - Recommendation: Don't report latency (like most granular plugins)

---

## Research References

### Professional Plugins

1. **Red Panda Particle**
   - Granular delay pedal with freeze functionality
   - Freeze holds buffer content while grains continue reading
   - Parameters: Delay (0-2.5s), Feedback, Filter, Mix
   - Observed: Freeze footswitch creates infinite sustain of frozen moment
   - Reference for: Freeze behavior implementation, feedback loop in freeze mode
   - [Source: Red Panda Lab Documentation](https://redpandalabs.com/particle)

2. **Arturia Efx Fragments**
   - Granular effects processor with texture modes
   - Parameters: Grain Size, Density, Filter, Mix, Randomization
   - Observed: Texture mode creates "grain clouds" similar to high-character GrainCosmos
   - Reference for: Density control, randomization systems
   - [Source: Arturia Efx Fragments Manual](https://www.arturia.com/resources/efx-fragments-manual)

3. **Output Portal**
   - Granular delay with pitch shifting, scale quantization
   - Parameters: Density, Grain Size, Pitch, Feedback, Mix
   - Observed: Professional reference for granular delay architecture
   - Reference for: Grain density parameter, pitch quantization approach
   - [Source: Output Audio Portal Manual](https://output.com/shop/portal)

4. **Mutable Instruments Clouds/Beads**
   - Real-time granular synthesis with delay paradigm
   - Parameters: SIZE (grain size), DENSITY (overlap), TEXTURE (character), PITCH, BLEND (dry/wet)
   - Observed: TEXTURE control for "glitchy to smooth" morphing is key inspiration for character parameter
   - Beads adds built-in reverb, envelope modulation
   - Internal processing: 32kHz 32-bit floating point
   - Reference for: Envelope modulation, density vs character interaction
   - [Source: Mutable Instruments Documentation](https://mutable-instruments.net/modules/clouds)

5. **Kaivo (Madrona Labs)**
   - Granular synthesizer with per-grain envelope control
   - Parameters: Envelope (ADSR), Grain Size, Overlap, Pitch
   - Observed: ADSR envelope per grain creates percussive-to-smooth morphing
   - Reference for: Envelope modulation system implementation
   - [Source: Kaivo Manual](https://madronalabs.com/media/kaivo/KaivoManual.pdf)

### JUCE Documentation

- **juce::dsp::DelayLine:** Variable delay with interpolation (Linear, Lagrange3rd)
  - Lagrange3rd recommended for pitch modulation
  - Prepare with ProcessSpec, process with AudioBlock
- **juce::dsp::WindowingFunction:** Window table generation (Hann, Blackman, rectangular)
  - Note: Tukey window not built-in, needs custom implementation
  - Alternative: Use Hann and scale crossfade portion
- **juce::dsp::DryWetMixer:** Latency-compensated dry/wet mixing
  - `pushDrySamples()` -> process -> `mixWetSamples()`
- **juce::Random:** Thread-safe random number generation
  - `getSystemRandom().nextFloat()` for 0.0-1.0 range
- **juce::AudioPlayHead:** Host transport state for tempo sync
  - `getCurrentPosition()` to get BPM
  - [Source: JUCE Documentation](https://docs.juce.com/master/classjuce_1_1AudioPlayHead.html)

### Technical Resources

- **Granular Synthesis Explained (PsychoSynth.com):**
  - Grain durations 10-50ms typical, density hundreds to thousands per second
  - Grain envelope: controls amplitude envelope (ADSR) of each grain
  - [Source: PsychoSynth Granular Synthesis](https://psychosynth.com/sound-synthesis/types-and-techniques/granular/)

- **Towards Per-Grain Parameterisation (NIME 2025):**
  - Research on interfacing with sound grains on "atomic" level
  - Per-grain parameter control for granular synthesizers
  - [Source: NIME 2025 Paper](https://nime.org/proceedings/2025/nime2025_21.pdf)

- **Sound In A Nutshell: Granular Synthesis:**
  - Explains how sound envelope determines grain duration and amplitude
  - Describes process of adding grain envelopes as "windowing"
  - [Source: GranularSynthesis.com](https://www.granularsynthesis.com/hthesis/envelope.html)

- **Waveshaping Fundamentals (Columbia University):**
  - Waveshaping as nonlinear transfer functions
  - Polynomial distortion creates harmonic enrichment
  - Transfer function: `f(x) = x + k*x^n` for odd/even harmonics
  - [Source: Columbia DSP](https://www.ee.columbia.edu/~ronw/code/MeapSoftDoc/MEAPObjects/reference/waveshaping.html)

- **Freeze Function (Red Panda Particle):**
  - FREEZE footswitch holds signal in delay line indefinitely
  - When input level drops below threshold, it rescans delay buffer
  - Can be activated by holding down TAP/FREEZE switch
  - [Source: Red Panda Particle Manual](https://redpandalabs.com/elements)

---

## Notes

- Dual envelope system (ADSR × Tukey) is the primary innovation over AngelGrain
  - ADSR provides temporal shaping (percussive ↔ smooth)
  - Tukey provides crossfade control (glitchy ↔ angelic)
  - Independent control via envelope_shape and character parameters
  - Risk: Parameter interaction may be confusing (UX testing needed)

- Waveshaping distortion placement pre-feedback allows timbral accumulation
  - Creates rich, evolving textures at high feedback
  - Risk: Can become harsh (users can lower distortion/feedback)

- Freeze mode enables infinite sustain of frozen moment
  - Continued feedback allows textural evolution within frozen buffer
  - Chaos parameter randomizes grain selection from frozen content
  - Creative use: Freeze interesting sound, vary chaos to explore frozen texture

- Envelope modulation increases CPU usage significantly (~10-15% over AngelGrain)
  - Pre-calculated envelope tables may be necessary if CPU exceeds 70%
  - Table strategy: 11 (character) × 11 (envelope_shape) = 121 pre-calculated tables

- Tempo sync is straightforward JUCE pattern using AudioPlayHead
  - Note division mapping: 1/16, 1/8, 1/4, 1/2, 1/1
  - No visualization planned for v1.0.0 (can add grain activity display in v1.1 if desired)

- Proven architecture: AngelGrain's 32-voice system is working implementation
  - Copy voice management, scheduler, buffer logic from AngelGrain
  - Modify envelope generation to add ADSR multiplication
  - Add distortion unit before feedback mixer
  - Add freeze state controller at buffer write

- Parameter ranges researched from creative brief and parameter-spec:
  - delay_time: 0-2s (reasonable for granular delay)
  - grain_size: 10-500ms (covers micro-grains to long textures)
  - envelope_shape: 0.0-1.0 (full crossfade range)
  - distortion_amount: 0-100% (full clean-to-heavy range)
  - All other parameters: Match AngelGrain (proven ranges)
